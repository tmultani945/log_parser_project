# Prompt for 0xB823 Payload Parser Script

## Task Overview
Create a standalone Python binary payload parser that reads metadata JSON (generated by the metadata extractor) and parses hex-encoded binary payloads according to the field definitions. The parser should handle different data types, nested table references, and little-endian byte order.

## Requirements

### 1. Dependencies
- **Standard library only**: `json`, `struct`, `sys`, `pathlib`, `typing`
- **No external decoder dependencies**: This is a standalone parser

### 2. Input Files and Data

**Metadata JSON Path** (hardcoded): `data/output/metadata_0xB823_v196610.json`

**Test Payload** (hex string, embedded in script):
```
02 00 03 00 01 01 00 7B 00 1A 80 2E
DE 40 18 30 01 E0 E5 09 00 4A DE 09
00 64 00 64 00 1A 80 2E DE 00 00 00
00 37 01 03 E0 01 00 08 01 16 00 4D
00
```

### 3. Core Classes and Architecture

#### Class: `PayloadParser`

**Initialization**: `__init__(self, metadata_path: str)`
- Load JSON metadata from file
- Support two metadata formats:
  - Simple format: metadata at root level
  - Full format: metadata nested under `"metadata"` key
- Build table index by calling `_build_table_index()`

**Method**: `_build_table_index(self)`
- Create a dictionary mapping table_number → table_definition
- Include three types of tables:
  1. **Pre-version tables** (e.g., Table 11-43: MajorMinorVersion)
  2. **Main table** (the primary structure for the version)
  3. **Dependent tables** (tables referenced by the main table)

Example index structure:
```python
self.tables = {
    '11-43': {
        'table_number': '11-43',
        'table_name': 'Table 11-43: MajorMinorVersion',
        'fields': [...]
    },
    '11-55': {
        'table_number': '11-55',
        'table_name': 'Table 11-55: NR5G Serving Cell Info',
        'fields': [...]
    }
}
```

### 4. Binary Data Parsing

#### Method: `_hex_string_to_bytes(self, hex_string: str) -> bytes`
- Remove all whitespace and newlines from hex string
- Convert to bytes using `bytes.fromhex()`
- Example: `"02 00 03 00"` → `b'\x02\x00\x03\x00'`

#### Method: `_read_bits(self, data: bytes, offset_bytes: int, offset_bits: int, length_bits: int) -> int`

**CRITICAL: Little-Endian Byte Order**

This method reads bits from a byte array using **little-endian byte order** (LSB first).

**For byte-aligned fields** (offset_bits == 0 and length_bits % 8 == 0):
- Use `struct.unpack()` with little-endian format codes:
  - 1 byte: `struct.unpack('<B', data[offset:offset+1])[0]`
  - 2 bytes: `struct.unpack('<H', data[offset:offset+2])[0]`
  - 4 bytes: `struct.unpack('<I', data[offset:offset+4])[0]`
  - 8 bytes: `struct.unpack('<Q', data[offset:offset+8])[0]`
  - Other sizes: Manual little-endian assembly:
    ```python
    value = 0
    for i, byte in enumerate(byte_slice):
        value |= byte << (i * 8)
    ```

**For bit-level fields** (not byte-aligned):
- Calculate total bit offset: `total_bit_offset = offset_bytes * 8 + offset_bits`
- Determine byte range: `start_byte = total_bit_offset // 8`, `end_byte = (total_bit_offset + length_bits + 7) // 8`
- Read bytes in little-endian order:
  ```python
  value = 0
  for i in range(start_byte, end_byte):
      byte_offset = i - start_byte
      value |= data[i] << (byte_offset * 8)
  ```
- Shift to align bits: `value >>= (total_bit_offset % 8)`
- Apply mask to extract only needed bits: `value &= (1 << length_bits) - 1`

**Error Handling**:
- Raise `ValueError` if not enough data is available

#### Method: `_parse_field_value(self, data: bytes, field: Dict[str, Any]) -> Tuple[Any, str]`

Parse a single field based on its type:

**Type: Uint (Uint8, Uint16, Uint32, etc.)**
- Return raw integer value
- Return type description: `f"Uint{length_bits}"`

**Type: Bool**
- Convert raw value to Python boolean
- Return type: `"Bool"`

**Type: Enumeration**
- Parse enum from field description using `_parse_enum_from_description()`
- Return enum string name
- Return type: `"Enumeration"`

**Type: Table reference (e.g., "Table 11-43")**
- Return raw value (will be processed recursively later)
- Return type: the table reference string (e.g., "Table 11-43")

**Type: Unknown**
- Return raw value
- Return original type_name

#### Method: `_parse_enum_from_description(self, description: str, value: int) -> str`

Extract enumeration string from field description:

Description format example:
```
• 0 – SINGLE STANDBY
• 1 – DUAL STANDBY DUAL ACTIVE
• 2 – TRIPLE STANDBY
```

**Parsing logic**:
- Split description by newlines
- Look for lines starting with `•` or `-`
- Parse pattern: `• <number> – <name>`
- Extract number and compare with the value
- Return the name if matched
- If no match found, return `str(value)`

### 5. Table and Structure Parsing

#### Method: `_parse_table(self, data: bytes, table_number: str, record_index: int = 0) -> Dict[str, Any]`

Parse a complete table structure from binary data:

**Process**:
1. Look up table definition from `self.tables`
2. Iterate through all fields in the table
3. For each field:
   - **If Type Name starts with "Table"**: This is a nested table reference
     - Extract referenced table number (e.g., "Table 11-43" → "11-43")
     - Recursively call `_parse_table()` for the nested table
     - **Merge nested fields into parent** (flatten the structure)
   - **Otherwise**: Parse as a simple field
     - Call `_parse_field_value()` to get value and type
     - Store in result dictionary with field name as key
     - Include metadata: value, type, offset_bytes, length_bits

**Field naming**:
- For the first record (record_index == 0): Use field name as-is
- For subsequent records (record_index > 0): Append `" (Record N)"` to field name

**Return structure**:
```python
{
    "System Frame Number": {
        "value": 123,
        "type": "Uint8",
        "offset_bytes": 0,
        "length_bits": 8
    },
    "Major": {
        "value": 3,
        "type": "Uint16",
        "offset_bytes": 2,
        "length_bits": 16
    }
}
```

#### Method: `parse_payload(self, payload_hex: str, version: int = None) -> Dict[str, Any]`

Main parsing method:

**Step 1: Convert hex to bytes**
- Use `_hex_string_to_bytes()`

**Step 2: Parse version from first 4 bytes**
- Use Table 11-43 (MajorMinorVersion) to parse the version structure
- If Table 11-43 not available, use fallback:
  ```python
  version_value = struct.unpack('<I', data[0:4])[0]
  major = (version_value >> 16) & 0xFFFF
  minor = version_value & 0xFFFF
  ```
- If Table 11-43 is available:
  - Parse first 4 bytes using `_parse_table(data[0:4], "11-43")`
  - Extract Major and Minor fields from parsed result
  - Calculate version_value: `(major << 16) | minor`

**Step 3: Verify version**
- Compare parsed version with expected version from metadata
- Raise `ValueError` if mismatch

**Step 4: Parse main payload**
- Get table number for this version from metadata
- Parse remaining payload (skip first 4 version bytes): `_parse_table(data[4:], table_number)`
- The main table will recursively parse dependent tables

**Step 5: Build result**
```python
{
    'logcode_id': '0xB823',
    'logcode_name': 'LTE/NR5G RRC OTA Packet',
    'version': {
        'value': 196610,
        'hex': '0x00030002',
        'major': 3,
        'minor': 2
    },
    'fields': {
        'System Frame Number': {'value': 1, 'type': 'Uint8', ...},
        ...
    }
}
```

### 6. Output Formatting

#### Function: `format_output(parsed_data: Dict[str, Any], metadata: Dict[str, Any]) -> Dict[str, Any]`

Convert raw parsed data to expected output format:

**Output structure**:
```json
{
  "Version": 196610,
  "LogRecordDescription": "LTE/NR5G RRC OTA Packet",
  "MajorMinorVersion": [
    {"MajorMinorVersion": "3.2"}
  ],
  "Serving Cell Info": [
    {
      "SystemFrameNumber": "1",
      "SubframeNumber": "1",
      "PhysicalCellId": "123",
      ...
    }
  ]
}
```

**Formatting rules**:
1. Extract version information
2. Create MajorMinorVersion array with single entry
3. Collect all fields into a single record
4. **Remove spaces from field names**: `"System Frame Number"` → `"SystemFrameNumber"`
5. **Remove "(Record N)" suffixes** from field names
6. Convert all values to strings:
   - Boolean → "0" or "1"
   - Other types → string representation
7. Place record in "Serving Cell Info" array

### 7. Main Function

#### Function: `main()`

**Process**:
1. Set up paths:
   - Metadata: `data/output/metadata_0xB823_v196610.json` (relative to script directory)
   - Output: `data/output/parsed_0xB823.json`
2. Check if metadata file exists
3. Load metadata JSON
4. Create `PayloadParser` instance
5. Parse the embedded test payload
6. Format output using `format_output()`
7. Display JSON output to console
8. Save JSON to output file
9. Return exit code (0 for success, 1 for error)

**Progress reporting**:
```
================================================================================
0xB823 Payload Parser
================================================================================

Initializing parser with metadata...
Parsing payload (53 bytes)...

================================================================================
PARSED OUTPUT:
================================================================================
{
  "Version": 196610,
  ...
}

================================================================================
Saved to: C:\path\to\parsed_0xB823.json
================================================================================
```

### 8. Error Handling
- Check if metadata file exists before loading
- Handle missing tables in metadata
- Handle insufficient payload data
- Handle version mismatches
- Print detailed error messages with traceback
- Return appropriate exit codes

### 9. Code Structure
```python
class PayloadParser:
    def __init__(self, metadata_path: str): ...
    def _build_table_index(self): ...
    def _hex_string_to_bytes(self, hex_string: str) -> bytes: ...
    def _read_bits(self, data: bytes, offset_bytes: int, offset_bits: int, length_bits: int) -> int: ...
    def _parse_field_value(self, data: bytes, field: Dict[str, Any]) -> Tuple[Any, str]: ...
    def _parse_enum_from_description(self, description: str, value: int) -> str: ...
    def _parse_table(self, data: bytes, table_number: str, record_index: int = 0) -> Dict[str, Any]: ...
    def parse_payload(self, payload_hex: str, version: int = None) -> Dict[str, Any]: ...

def format_output(parsed_data: Dict[str, Any], metadata: Dict[str, Any]) -> Dict[str, Any]: ...

def main(): ...

if __name__ == "__main__":
    sys.exit(main())
```

### 10. Implementation Details
- Use type hints for all function signatures
- Use docstrings for all classes and methods
- No external dependencies (pure stdlib)
- Handle Unicode properly (`encoding='utf-8'`)
- Use `pathlib.Path` for file operations
- Use f-strings for formatting

### 11. Expected Usage
```bash
# Run with embedded test payload
python parse_payload_0xB823.py
```

## Key Design Decisions

1. **Standalone design**: No external decoder dependencies, reads everything from metadata JSON
2. **Little-endian byte order**: Uses struct module and manual bit manipulation with proper byte ordering
3. **Recursive table parsing**: Automatically follows table references and flattens nested structures
4. **Dynamic version parsing**: Uses metadata-defined Table 11-43 instead of hardcoded version parsing
5. **Enum description parsing**: Extracts human-readable enum names from field descriptions
6. **Flexible metadata format**: Supports both simple and nested metadata JSON structures
7. **Field flattening**: Nested tables are merged into parent structure for simpler output

## Expected Behavior

Given the test payload, the parser should:
1. Extract version: 196610 (0x00030002 = major 3, minor 2)
2. Parse all fields according to Table 11-55 and dependencies
3. Output structured JSON with all field values
4. Save to output file

The parser validates that the payload version matches the metadata version before parsing.
